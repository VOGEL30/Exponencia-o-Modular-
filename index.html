<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Exponenciação Modular — Algoritmo Matemático</title>

  <!-- MATHJAX PARA EXPRESSÕES EM LaTeX -->
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    :root{
      --bg:#faf6ff;
      --card:#ffffff;
      --muted:#6b7280;
      --accent:#e9d5ff;
      --accent2:#fdf2f8;
    }
    *{box-sizing:border-box;font-family:Inter, ui-sans-serif, system-ui, sans-serif;}
    body{
      margin:0;
      background:linear-gradient(180deg,var(--accent2),var(--bg));
      min-height:100vh;
      padding:24px;
      display:flex;
      justify-content:center;
    }
    .card{
      width:100%;
      max-width:900px;
      background:var(--card);
      padding:32px;
      border-radius:14px;
      box-shadow:0 8px 30px rgba(0,0,0,0.06);
    }
    h1{margin:0 0 8px;font-size:26px;}
    p.lead{color:var(--muted);margin-bottom:16px;}

    .grid{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:16px;
      margin-bottom:16px;
    }
    @media(max-width:700px){.grid{grid-template-columns:1fr;}}
    label{margin-bottom:4px;display:block;color:var(--muted);}
    input{
      width:100%;
      padding:10px;
      border:1px solid #ddd;
      border-radius:8px;
      font-size:15px;
    }
    button{
      background:#7c3aed;
      color:white;
      border:none;
      padding:12px 18px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      transition:0.2s;
    }
    button:hover{opacity:0.85;}
    .secondary{
      background:#fff;
      border:1px solid #d1d5db;
      color:#374151;
    }
    .result{
      margin-top:18px;
      background:#f8fafc;
      padding:16px;
      border-radius:8px;
      border:1px solid #e2e8f0;
      font-family:ui-monospace, monospace;
    }
    .log{
      margin-top:16px;
      padding:16px;
      border-radius:8px;
      border:1px dashed #d8b4fe;
      background:#ffffff;
      max-height:260px;
      overflow:auto;
      font-family:ui-monospace, monospace;
      font-size:14px;
      white-space:pre-wrap;
    }
    .section-title{
      font-size:20px;
      margin-top:28px;
      margin-bottom:8px;
      font-weight:600;
    }
  </style>
</head>

<body>
<div class="card">

  <h1>Exponenciação Modular — \(a^k \bmod n\)</h1>
  <p class="lead">Algoritmo matemático formal + execução passo a passo.</p>

  <!-- ============================ INPUTS ============================ -->
  <div class="grid">
    <div>
      <label>Base \(a\)</label>
      <input id="a" type="text" value="7">
    </div>
    <div>
      <label>Expoente \(k\)</label>
      <input id="k" type="text" value="128">
    </div>
    <div>
      <label>Módulo \(n\)</label>
      <input id="n" type="text" value="19">
    </div>
    <div style="display:flex; gap:8px; align-items:flex-end;">
      <button id="calc">Calcular</button>
      <button class="secondary" id="clear">Limpar</button>
    </div>
  </div>

  <!-- ============================ RESULTADO ============================ -->
  <div class="result" id="output">Resultado: —</div>

  <!-- ============================ LOG ============================ -->
  <div class="log" id="log" hidden></div>

  <!-- ============================ EXPLICAÇÃO TEÓRICA ============================ -->
  <h2 class="section-title">1. Definição formal</h2>
  <p>
    Dado um inteiro \(a\), um expoente inteiro não negativo \(k\) e um módulo inteiro positivo \(n\), definimos:
  </p>

  <p style="font-size:18px; text-align:center;">
    \[
      a^k \bmod n = r \quad \text{tal que} \quad r \equiv a^k \pmod{n}
    \]
  </p>

  <p>
    Isso significa que \(r\) é o resto da divisão inteira de \(a^k\) por \(n\).
  </p>

  <h2 class="section-title">2. Expansão binária do expoente</h2>
  <p>
    Escrevemos o expoente \(k\) em base 2:
  </p>

  <p style="text-align:center;font-size:17px;">
    \[
      k = b_0 2^0 + b_1 2^1 + \dots + b_m 2^m,
    \]
  </p>

  <p>
    onde cada \(b_i \in \{0,1\}\).  
    Assim,
  </p>

  <p style="text-align:center;font-size:17px;">
    \[
      a^k = a^{b_0 2^0} a^{b_1 2^1} \cdots a^{b_m 2^m}.
    \]
  </p>

  <p>
    Quando \(b_i = 1\), multiplicamos; quando \(b_i = 0\), apenas avançamos elevando ao quadrado.
  </p>

  <h2 class="section-title">3. Ideia do algoritmo</h2>
  <p>
    A cada etapa:
  </p>
  <ul>
    <li>Se o último bit de \(k\) é 1 → multiplicamos no acumulador.</li>
    <li>Sempre elevamos a base ao quadrado.</li>
    <li>Reduzimos módulo \(n\) a cada operação para evitar números gigantes.</li>
  </ul>

  <h2 class="section-title">4. Passo-a-passo na execução</h2>
  <p>
    O sistema mostrará:
  </p>
  <ul>
    <li>o bit atual de \(k\)</li>
    <li>se houve multiplicação ou não</li>
    <li>o valor da base ao quadrado</li>
    <li>a redução módulo \(n\)</li>
  </ul>

</div>

<script>
// ========================= FUNÇÕES DE APOIO =========================

function toBigIntStrict(s){
  s = s.trim();
  if(!/^[-+]?\d+$/.test(s)) throw new Error("Digite um número inteiro válido.");
  return BigInt(s);
}

function mod(a, n){
  const r = a % n;
  return (r + n) % n;
}

// ========================= ALGORITMO MODULAR =========================

function modPow(a, k, n, record = true){
  let base = mod(a, n);
  let exp = k;
  let result = 1n;

  const steps = [];
  if(record) steps.push(`Início → base = ${base}, expoente = ${exp}, módulo = ${n}`);

  while(exp > 0n){
    const bit = exp % 2n;

    if(bit === 1n){
      result = mod(result * base, n);
      if(record) steps.push(`bit = 1 → multiplica: result = result × base mod n = ${result}`);
    } else {
      if(record) steps.push(`bit = 0 → não multiplica (result permanece ${result})`);
    }

    base = mod(base * base, n);
    exp /= 2n;

    if(record) steps.push(`eleva ao quadrado → nova base = ${base}, novo expoente = ${exp}`);
  }

  return {res: result, steps};
}

// ========================= EVENTOS =========================

const out = document.getElementById("output");
const log = document.getElementById("log");

document.getElementById("calc").addEventListener("click", () => {
  try{
    const a = toBigIntStrict(document.getElementById("a").value);
    const k = toBigIntStrict(document.getElementById("k").value);
    const n = toBigIntStrict(document.getElementById("n").value);

    if(n <= 0n) throw new Error("n deve ser positivo.");
    if(k < 0n) throw new Error("k deve ser não negativo.");

    const showSteps = true;
    const t0 = performance.now();

    const {res, steps} = modPow(a, k, n, showSteps);

    const t1 = performance.now();

    out.innerHTML = `Resultado: <strong>${res}</strong><br>
                     <small>Tempo: ${(t1 - t0).toFixed(3)} ms</small>`;

    log.hidden = false;
    log.innerHTML = steps.join("\n");

  }catch(e){
    out.innerHTML = `<span style="color:#b91c1c;">Erro: ${e.message}</span>`;
    log.hidden = true;
  }
});

document.getElementById("clear").addEventListener("click", ()=>{
  log.hidden = true;
  log.innerHTML = "";
});
</script>

</body>
</html>
